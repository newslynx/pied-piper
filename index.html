<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Create a zip file demo</title>
<link rel="stylesheet" href="demo.css">
</head>

<body>
	<div id="container">

		<div class="description">
			A JavaScript library to zip and unzip files
			<hr>
		</div>
		
		<h2>Create a zip file demo</h2>
		
		<ol id="demo-container">
			<li>
				<span class="form-label">download the zip file</span>
				<a id="download-button" href="#">Download</a>
			</li>
		</ol>

	</div>
	<script type="text/javascript" src="zip.js"></script>
	<!-- Used to loop over objects, convenience -->
	<script type="text/javascript" src="js/thirdparty/underscore-min.js"></script> 
	<!-- Converts array of objects into csv format, could also just be the dsv library -->
	<script type="text/javascript" src="js/thirdparty/d3.v3.min.js"></script> 
	<script>

		// Cache the `createObjectURL` function cross-browserly
		var WINDOW = window,
				URL = WINDOW.webkitURL || WINDOW.mozURL || WINDOW.URL,
				createObjectURL = URL.createObjectURL; // Convert a compressed blob object to a data URL

	  var in_data = {
	  	student_one: [{name: 'michael'}],
	  	student_two: [{name: 'henry'}]
	  };

		zipMultiple(in_data, 'dict', 'csv', function(zippedBlob) {
			var zipped_blog_href = createObjectURL(zippedBlob);
			var DOM_download_btn = document.getElementById('download-button');
			DOM_download_btn.href = zipped_blog_href;
			DOM_download_btn.download = 'newslynx-data.zip';
		});

		// Take in a list of things or a dictionary and output a zip of those files
		// Can convert them to `csv` if so desired
		function zipMultiple(files, inputFormat, outputFormat, cb) {
			var addIndex = 0,
					writer = new zip.BlobWriter("application/zip"),
					zipWriter;

			// They need to be turned into an array of strings
			files_reformatted = formatFiles(files, inputFormat, outputFormat);

			function nextFile() {
				var file = files_reformatted[addIndex],
				 		blob = new Blob([ file.data ], { type : "text/plain" }),
						blob_reader = new zip.BlobReader(blob),
						filename = file.name || 'file-'+addIndex;

				zipWriter.add(filename+'.'+outputFormat, blob_reader, function(){
					addIndex++;
					if (addIndex < files_reformatted.length) {
						nextFile();
					} else {
						zipWriter.close(cb);
					}
				});
			}

			function formatFiles(files, inputFormat, outputFormat){
				// Deep copy this
				// TODO, use jQuery extend if that's faster
				var reformatted = JSON.parse(JSON.stringify(files)),
						tmp = [];

				// `inputFormat` can be `list` or `dict`
				// If it's list we need to map it to having an object of the format below
				// If it's a `dict` we need to convert that to a list-ish object, stashing the key as `<list_item>.name`
				if (inputFormat == 'dict') {
					_.each(reformatted, function(value, key, dict){
						var obj = {};
						obj.data = value;
						obj.name = key;
						tmp.push(obj);
					});
					reformatted = tmp;
				} else if (inputFormat == 'list'){
					reformatted.forEach(function(val, index){
						var obj = {};
						obj.data = val;
						obj.name = 'file-'+index;
					});
				}

				// `outputFormat` can be `txt` or `csv`
				// It will return an object of the format {name: :string, data: :string}
				// If it's text, stringify the value of data
				if (outputFormat == 'txt'){
					reformatted.forEach(function(val){
						if (typeof val.data != 'string'){
							val.data = JSON.stringify(val.data);
						}
					});
				} else if (outputFormat == 'csv') {
					reformatted.forEach(function(val){
						val.data = d3.csv.format(val.data);
					});
				}

				return reformatted;
			}

			zip.createWriter(writer, function(writer) {
				zipWriter = writer;
				nextFile();
			}, reportError);

		}

		// function unzipBlob(blob, callback) {
		//   // use a zip.BlobReader object to read zipped data stored into blob variable
		//   zip.createReader(new zip.BlobReader(blob), function(zipReader) {
		//     // get entries from the zip file
		//     zipReader.getEntries(function(entries) {
		//       // get data from the first file
		//       entries[0].getData(new zip.BlobWriter("text/plain"), function(data) {
		//         // close the reader and calls callback function with uncompressed data as parameter
		//         zipReader.close();
		//         callback(data);
		//       });
		//     });
		//   }, reportError);
		// }

		function reportError(message) {
		  console.error(message);
		}
	</script>
</body>
</html>